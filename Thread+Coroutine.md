# Notes
- 多线程+协程相关随笔，学习记录
-------------
目录
-------------
* c++线程中的几种锁
  - 线程之间的锁有：互斥锁、条件锁、自旋锁、读写锁、递归锁，一般而言，锁的功能越强大，性能就越低
  - 互斥锁：
      - 互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中有多个空闲线程和一个任务队列。任何一个线程都要使用互斥锁访问任务队列，以避免多个线程同时访问任务队列以发生错乱。
      - 在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程不能够获取该互斥锁。如果其他线程想要获取这个互斥锁，只能以阻塞的方式进行等待。
      - 其中lock()表示以阻塞方式进行加锁，如果之前mutex被加锁了，那么程序会阻塞在这里
      - trylock()表示以非阻塞方式进行加锁，不会等待而是马上返回，失败返回0
  - 条件锁：
      - 条件锁就是需要一个条件才能唤醒线程，比如多个线程共用一个变量，一个线程在对变量修改时达到另一个已经挂起的线程的条件，当前线程就会把另一个线程唤醒。
  - 读写锁：
      - 读写锁就是把读锁和写锁分离，多个线程可以同时获得读锁，但是读锁被获取时不能有线程获取到写锁。而有写锁被获取时，读锁和写锁都不能再被获取。目的是让多个线程可以同时读取某个共用数据，而当有线程写入共用数据时保证该线程是独占这块数据的。      
  - 自旋锁：
      - 通过死循环不断检测是否达到释放锁的条件，如果达到就释放锁，否则就继续循环。
* pthread
  - 互斥锁的创建：
      - 静态创建：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
      - 动态创建：int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr);
      - 参数attr指定了新建互斥锁的属性，如果该参数为空，则使用默认的互斥锁属性，默认属性为快速互斥锁。
      - 成功返回 0。
  - 互斥锁属性的创建：
      - pthread_mutexattr_t attr;
  - 互斥锁属性的初始化：
      - pthread_mutexattr_init(&attr); 成功返回0
  - 设置互斥锁属性：
      - pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_ERRORCHECK);
      - PTHREAD_MUTEX_TIMED 缺省值，也就是普通锁，当一个线程加锁后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。保证了资源分配的公平性
      - PTHREAD_MUTEX_RECURSIVE 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争
      - PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED类型动作相同，这样保证了当不允许多次加锁时不会出现最简单的死锁
      - PTHREAD_MUTEX_ADAPTIVE 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
      - 可以用 pthread_mutexattr_settype(pthread_mutexattr_t *attr , int type);设置锁类型
      - pthread_mutexattr_gettype(pthread_mutexattr_t *attr , int *type);获取锁类型
  - -pthread
      - 包含头文件仅能说明了线程函数的声明， 但是还没有实现， 加上-pthread是在链接阶段，链接这个库。
  - 互斥锁加锁，解锁，尝试加锁，销毁：
      - int pthread_mutex_lock(pthread_mutex_t *mutex);成功返回0
      - int pthread_mutex_unlock(pthread_mutex_t *mutex);成功返回0
      - bool pthread_mutex_trylock(pthread_mutex_t *mutex);成功返回true
      - int pthread_mutex_destroy(pthread_mutex_t *mutex);成功返回0
  - 线程id：
      - 线程和进程都有自己的id，这个id就叫做pid，pthread库里的每一个线程都对应一个内核线程，都是有单独的pid
      - 获取线程自身id：pthread_t pthread_self(void); pthread_t的类型为unsigned long int
  - pthread_join()函数：
      - 当前线程挂起，线程阻塞等待子线程结束，然后回收子线程资源
      - int pthread_join(pthread_t tid, void**thread_return); 
      - 成功则返回0，失败返回非0
  - pthread_detach()函数：
      - 分离线程，不阻塞
      - int pthread_detach(pthread_t tid);
      - 成功则返回0，失败返回非0
      
